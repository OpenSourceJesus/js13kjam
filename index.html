<!DOCTYPE html>
<html style="width:9999px;height:9999px;overflow:hidden">
<body>

<svg id="Cube_63" style="position:absolute;z-index:-1125604" width="1920.0pt" height="1080.0pt" viewBox="0 0 1920.0 1080.0"  preserveAspectRatio="xMidYMid meet">  <g transform="translate(0.0,1080.0) scale(0.1,-0.1)" fill="rgb(204.0 204.0 204.0)" stroke="none"> <path d="M7892 8355 c-980 -304 -1785 -555 -1788 -558 -5 -5 25 -530 71 -1232 36 -543 185 -2957 185 -2988 l0 -34 1555 -947 1555 -946 43 21 c23 12 229 122 457 244 1072 575 1819 976 2305 1235 292 156 533 286 538 290 4 3 16 148 27 321 28 433 239 3841 242 3909 l3 54 -280 97 c-298 104 -1016 353 -2245 779 -415 144 -784 272 -820 285 l-65 22 -1783 -552z"/> </g> </svg> 
<script type="module">

var svgNS = 'http://www.w3.org/2000/svg';
function dot (from, to)
{
	return from[0] * to[0] + from[1] * to[1];
}
function ang (from, to)
{
	return Math.acos(dot(normalize(from), normalize(to))) * (180 / Math.PI);
}
function signed_ang (from, to)
{
	return ang(from, to) * Math.sign(from[0] * to[1] - from[1] * to[0]);
}
function rotate (v, ang)
{
	ang /= 180 / Math.PI;
	ang += Math.atan2(v[1], v[0]);
	var mag = magnitude(v);
	return [Math.cos(ang) * mag, Math.sin(ang) * mag];
}
function rotate_to (from, to, maxAng)
{
	return rotate(from, clamp(signed_ang(from, to), -maxAng, maxAng));
}
function get_pos_and_size (elmt)
{
	return [[parseInt(elmt.getAttribute('x')), parseInt(elmt.getAttribute('y'))], [parseInt(elmt.getAttribute('width')), parseInt(elmt.getAttribute('height'))]];
}
function lerp (min, max, t)
{
	return min + t * (max - min);
}
function clamp (n, min, max)
{
	return Math.min(Math.max(n, min), max);
}
function inv_lerp (from, to, n)
{
	return (n - from) / (to - from);
}
function remap (inFrom, inTo, outFrom, outTo, n)
{
	return lerp(outFrom, outTo, inv_lerp(inFrom, inTo, n));
}
function overlaps (min, max, min2, max2)
{
	return !(max[0] < min2[0]
		|| min[0] > max2[0]
		|| max[1] < min2[1]
		|| min[1] > max2[1]);
}
function ang_to_dir (ang)
{
	return [Math.cos(ang), Math.sin(ang)];
}
function random_vector (maxDist)
{
	var dist = random(0, maxDist);
	var ang = random(0, 2 * Math.PI);
	var dir = ang_to_dir(ang);
	return [dir[0] * dist, dir[1] * dist];
}
function magnitude (v)
{
	return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function magnitude_vec (v)
{
	return Math.sqrt(v.x * v.x + v.y * v.y);
}
function normalize (v)
{
	return divide(v, magnitude(v));
}
function normalize_vec (v)
{
	return divide_vec(v, magnitude_vec(v));
}
function multiply (v, f)
{
	return [v[0] * f, v[1] * f];
}
function multiply_vec (v, f)
{
	return {x : v.x * f, y : v.y * f};
}
function divide (v, f)
{
	return [v[0] / f, v[1] / f];
}
function divide_vec (v, f)
{
	return {x : v.x / f, y : v.y / f};
}
function add (v, v2)
{
	return [v[0] - v2[0], v[1] - v2[1]];
}
function add_vec (v, v2)
{
	return {x : v.x + v2.x, y : v.y + v2.y};
}
function subtract (v, v2)
{
	return [v[0] - v2[0], v[1] - v2[1]];
}
function subtract_vec (v, v2)
{
	return {x : v.x - v2.x, y : v.y - v2.y};
}
function random (min, max)
{
	return Math.random() * (max - min) + min;
}
function add_group (id, pos, childIds = [], attributes = {}, txt = '')
{
	var group = document.createElementNS(svgNS, 'g');
	group.id = id;
	group.setAttribute('x', pos[0]);
	group.setAttribute('y', pos[1]);
	group.innerHTML = txt;
	for (var [key, val] of Object.entries(attributes))
		group.setAttribute(key, val);
	for (var childId of childIds)
	{
		var node = document.getElementById(childId);
		node.style.position = 'fixed';
		group.appendChild(node);
	}
	document.body.appendChild(group);
	return group;
}
function shuffle (arr)
{
	var currIdx = arr.length;
	while (currIdx != 0)
	{
		var randIdx = Math.floor(Math.random() * currIdx);
		currIdx --;
		[arr[currIdx], arr[randIdx]] = [arr[randIdx], arr[currIdx]];
	}
}


class api
{
	get_svg_paths_and_strings (framesStrings, cyclic)
	{
		var pathsVals = [];
		var pathsStrings = [];
		var i = 0;
		for (var frameStr of framesStrings)
		{
			if (i == 0)
				var prevPathStr = frameStr;
			else
				for (var i2 = 0; i2 < frameStr.length; i2 += 2)
				{
					var idx = frameStr.charCodeAt(i2) - 32;
					prevPathStr = prevPathStr.slice(0, idx) + String.fromCharCode(prevPathStr.charCodeAt(idx) + frameStr.charCodeAt(i2 + 1) - 160) + prevPathStr.slice(idx + 1);
				}
			pathsVals.push($.get_svg_path(prevPathStr, cyclic));
			pathsStrings.push(prevPathStr);
			i ++;
		}
		return [pathsVals, pathsStrings];
	}
	get_svg_path (pathStr, cyclic)
	{
		var output = 'M ' + pathStr.charCodeAt(0) + ',' + pathStr.charCodeAt(1) + ' ';
		for (var i = 2; i < pathStr.length; i += 2)
		{
			if ((i - 2) % 6 == 0)
				output += 'C ';
			output += '' + pathStr.charCodeAt(i) + ',' + pathStr.charCodeAt(i + 1) + ' '
		}
		if (cyclic)
			output += 'Z';
		return output;
	}
	copy_node (id, newId, pos, rot = 0, attributes = {})
	{
		var copy = document.getElementById(id).cloneNode(true);
		copy.id = newId;
		copy.setAttribute('x', pos[0]);
		copy.setAttribute('y', pos[1]);
		copy.style.transform = 'translate(' + pos[0] + ',' + pos[1] + ')rotate(' + rot + 'deg)';
		for (var [key, val] of Object.entries(attributes))
			copy.setAttribute(key, val);
		document.body.appendChild(copy);
		var colliders = [];
		// Physics Section Start
		var rigidBody = rigidBodiesIds[id];
		if (rigidBody)
		{
			rigidBodiesIds[newId] = world.createRigidBody(new RAPIER.RigidBodyDesc(rigidBody.bodyType()).setAngularDamping(rigidBody.angularDamping()).setCanSleep(rigidBodyDescsIds[id].canSleep).setCcdEnabled(rigidBody.isCcdEnabled()).setDominanceGroup(rigidBody.dominanceGroup()).setEnabled(rigidBody.isEnabled()).setGravityScale(rigidBody.gravityScale()).setLinearDamping(rigidBody.linearDamping()).lockRotations(rigidBody.lockRotations()).setRotation(rot).setTranslation(pos[0], pos[1]));
			for (var i = 0; i < rigidBody.numColliders(); i ++)
				colliders.push(rigidBody.collider(i));
		}
		var collider = collidersIds[id];
		if (collider)
		{
			var newColliderDesc = new RAPIER.ColliderDesc(collider.shape).setActiveEvents(collider.activeEvents).setCollisionGroups(collider.collisionGroups).setDensity(collider.density).setEnabled(collider.enabled).setRotation(collider.rotation).setTranslation(pos[0], pos[1]);
			if (rigidBody)
				collider = world.createCollider(newColliderDesc, rigidBodiesIds[newId]);
			else
			{
				collider = world.createCollider(newColliderDesc);
				collidersIds[newId] = collider;
			}
			colliders.push(collider);
		}
		// Physics Section End
		return [copy, colliders];
	}
	add_radial_gradient (id, pos, zIdx, diameter, clr, clr2, clr3, clrPositions, subtractive)
	{
		var group = document.createElementNS(svgNS, 'g');
		group.id = id;
		group.setAttribute('x', pos[0]);
		group.setAttribute('y', pos[1]);
		var mixMode = 'lighter';
		if (subtractive)
			mixMode = 'darker';
		group.style = 'position:absolute;left:' + (pos[0] + diameter / 2) + 'px;top:' + (pos[1] + diameter / 2) + 'px;background-image:radial-gradient(rgba(' + clr[0] + ',' + clr[1] + ',' + clr[2] + ',' + clr[3] + ') ' + clrPositions[0] + '%, rgba(' + clr2[0] + ',' + clr2[1] + ',' + clr2[2] + ',' + clr2[3] + ') ' + clrPositions[1] + '%, rgba(' + clr3[0] + ',' + clr3[1] + ',' + clr3[2] + ',' + clr3[3] + ') ' + clrPositions[2] + '%);width:' + diameter + 'px;height:' + diameter + 'px;z-index:' + zIdx + ';mix-blend-mode:plus-' + mixMode;
		document.body.appendChild(group);
	}
	draw_svg (positions, posPingPong, size, fillClr, lineWidth, lineClr, id, pathFramesStrings, cyclic, zIdx, attributes, jiggleDist, jiggleDur, jiggleFrames, rotAngRange, rotDur, rotPingPong, scaleXRange, scaleYRange, scaleDur, scaleHaltDurAtMin, scaleHaltDurAtMax, scalePingPong, origin, fillHatchDensity, fillHatchRandDensity, fillHatchAng, fillHatchWidth, lineHatchDensity, lineHatchRandDensity, lineHatchAng, lineHatchWidth, mirrorX, mirrorY, capType, joinType, dashArr, cycleDur)
	{
		var fillClrTxt = 'rgb(' + fillClr[0] + ' ' + fillClr[1] + ' ' + fillClr[2] + ')';
		var lineClrTxt = 'rgb(' + lineClr[0] + ' ' + lineClr[1] + ' ' + lineClr[2] + ')';
		var pos = positions[0];
		var svg = document.createElementNS(svgNS, 'svg');
		svg.setAttribute('fill-opacity', fillClr[3] / 255);
		svg.id = id;
		svg.style = 'z-index:' + zIdx + ';position:absolute';
		svg.setAttribute('transform-origin', origin[0] + '% ' + origin[1] + '%');
		svg.setAttribute('x', pos[0]);
		svg.setAttribute('y', pos[1]);
		svg.setAttribute('width', size[0]);
		svg.setAttribute('height', size[1]);
		var trs = 'translate(' + pos[0] + ',' + pos[1] + ')';
		svg.setAttribute('transform', trs);
		var i = 0;
		var pathsValsAndStrings = $.get_svg_paths_and_strings(pathFramesStrings, cyclic);
		var anim;
		var frames;
		var firstFrame = '';
		for (var pathVals of pathsValsAndStrings[0])
		{
			var path = document.createElementNS(svgNS, 'path');
			path.id = id + ' ';
			if (i > 0)
				path.setAttribute('opacity', 0);
			path.style = 'fill:' + fillClrTxt + ';stroke-width:' + lineWidth + ';stroke:' + lineClrTxt;
			path.setAttribute('d', pathVals);
			if (jiggleFrames > 0)
			{
				anim = document.createElementNS(svgNS, 'animate');
				anim.setAttribute('attributename', 'd');
				anim.setAttribute('repeatcount', 'indefinite');
				anim.setAttribute('dur', jiggleDur + 's');
				frames = '';
				for (var i2 = 0; i2 < jiggleFrames; i2 ++)
				{
					pathVals = pathsValsAndStrings[1][i];
					for (var i3 = 0; i3 < pathVals.length; i3 += 2)
					{
						off = normalize(random_vector(1));
						off = [off[0] * jiggleDist, off[1] * jiggleDist];
						pathVals = pathVals.slice(0, i3) + String.fromCharCode(pathVals.charCodeAt(i3) + off[0]) + String.fromCharCode(pathVals.charCodeAt(i3 + 1) + off[1]) + pathVals.slice(i3 + 2);
					}
					pathVals = $.get_svg_path(pathVals, cyclic);
					if (i2 == 0)
					{
						firstFrame = pathVals;
						anim.setAttribute('from', pathVals);
						anim.setAttribute('to', pathVals);
					}
					frames += pathVals + ';';
				}
				anim.setAttribute('values', frames + firstFrame);
				path.appendChild(anim);
			}
			svg.appendChild(path);
			i ++;
		}
		for (var [key, val] of Object.entries(attributes))
			svg.setAttribute(key, val);
		document.body.appendChild(svg);
		var off = lineWidth / 2 + jiggleDist;
		var min = 32 - off;
		svg.setAttribute('viewbox', min + ' ' + min + ' ' + (size[0] + off * 2) + ' ' + (size[1] + off * 2));
		svg = document.getElementById(id);
		path = document.getElementById(id + ' ');
		var svgRect = svg.getBoundingClientRect();
		var pathRect = path.getBoundingClientRect();
		path.style.transform = 'translate(' + (svgRect.x - pathRect.x + off) + 'px,' + (svgRect.y - pathRect.y + off) + 'px)';
		if (rotDur > 0)
		{
			anim = document.createElementNS(svgNS, 'animatetransform');
			anim.setAttribute('attributename', 'transform');
			anim.setAttribute('type', 'rotate');
			anim.setAttribute('repeatcount', 'indefinite');
			anim.setAttribute('dur', rotDur + 's');
			firstFrame = rotAngRange[0];
			anim.setAttribute('from', firstFrame);
			frames = firstFrame + ';' + rotAngRange[1];
			if (rotPingPong)
			{
				anim.setAttribute('to', firstFrame);
				frames += ';' + firstFrame;
			}
			else
				anim.setAttribute('to', rotAngRange[1]);
			anim.setAttribute('values', frames);
			anim.setAttribute('additive', 'sum');
			svg.innerHTML += anim.outerHTML;
		}
		var totalScaleDur = scaleDur + scaleHaltDurAtMin + scaleHaltDurAtMax;
		if (totalScaleDur > 0)
		{
			anim = document.createElementNS(svgNS, 'animatetransform');
			anim.setAttribute('attributename', 'transform');
			anim.setAttribute('type', 'scale');
			anim.setAttribute('repeatcount', 'indefinite');
			if (scalePingPong)
				totalScaleDur += scaleDur;
			anim.setAttribute('dur', totalScaleDur + 's');
			firstFrame = scaleXRange[0] + ' ' + scaleYRange[0];
			anim.setAttribute('from', firstFrame);
			var thirdFrame = scaleXRange[1] + ' ' + scaleYRange[1];
			frames = firstFrame + ';' + firstFrame + ';' + thirdFrame + ';' + thirdFrame;
			var time = scaleHaltDurAtMin / totalScaleDur;
			var times = '0;' + time + ';';
			time += scaleDur / totalScaleDur;
			times += time + ';';
			time += scaleHaltDurAtMax / totalScaleDur;
			times += time;
			if (scalePingPong)
			{
				anim.setAttribute('to', firstFrame);
				frames += ';' + firstFrame;
				times += ';' + 1;
			}
			else
				anim.setAttribute('to', thirdFrame);
			anim.setAttribute('values', frames);
			anim.setAttribute('keytimes', times);
			anim.setAttribute('additive', 'sum');
			svg.innerHTML += anim.outerHTML;
		}
		if (cycleDur != 0)
		{
			anim = document.createElementNS(svgNS, 'animate');
			anim.setAttribute('attributename', 'stroke-dashoffset');
			anim.setAttribute('repeatcount', 'indefinite');
			var pathLen = path.getTotalLength();
			anim.setAttribute('dur', cycleDur + 's');
			anim.setAttribute('from', 0);
			anim.setAttribute('to', pathLen);
			anim.setAttribute('values', '0;' + pathLen);
			path.appendChild(anim);
		}
		document.getElementById(id + ' ').remove();
		svg.appendChild(path);
		var capTypes = ['butt', 'round', 'square'];
		svg.style.strokeLinecap = capTypes[capType];
		var joinTypes = ['arcs', 'bevel', 'miter', 'miter-clip', 'round'];
		svg.style.strokeLinejoin = joinTypes[joinType];
		svg.style.strokeDasharray = dashArr;
		if (magnitude(fillHatchDensity) > 0)
		{
			var args = [fillClr, true, svg, path]; 
			if (fillHatchDensity[0] > 0)
				$.hatch ('_' + id, ...args, fillHatchDensity[0], fillHatchRandDensity[0], fillHatchAng[0], fillHatchWidth[0]);
			if (fillHatchDensity[1] > 0)
				$.hatch ('|' + id, ...args, fillHatchDensity[1], fillHatchRandDensity[1], fillHatchAng[1], fillHatchWidth[1]);
			lineClr[3] = 255;
		}
		if (magnitude(lineHatchDensity) > 0)
		{
			var args = [lineClr, false, svg, path]; 
			if (lineHatchDensity[0] > 0)
				$.hatch ('@' + id, ...args, lineHatchDensity[0], lineHatchRandDensity[0], lineHatchAng[0], lineHatchWidth[0]);
			if (lineHatchDensity[1] > 0)
				$.hatch ('$' + id, ...args, lineHatchDensity[1], lineHatchRandDensity[1], lineHatchAng[1], lineHatchWidth[1]);
			lineClr[3] = 255;
		}
		svg.setAttribute('stroke-opacity', lineClr[3] / 255);
		if (mirrorX)
		{
			svg = $.copy_node(id, '~' + id, pos);
			svg.setAttribute('transform', trs + 'scale(-1,1)');
			svg.setAttribute('transform-origin', 50 - (origin[0] - 50) + '% ' + origin[1] + '%');
		}
		if (mirrorY)
		{
			svg = $.copy_node(id, '`' + id, pos);
			svg.setAttribute('transform', trs + 'scale(1,-1)');
			svg.setAttribute('transform-origin', origin[0] + '% ' + (50 - (origin[1] - 50)) + '%');
		}
		var pathRect = svg.children[svg.children.length - 1].getBoundingClientRect();
		for (var i = svg.children.length - 2; i >= 0; i --)
		{
			var child = svg.children[i];
			var childRect = child.getBoundingClientRect();
			var pathAnchor = [lerp(pathRect.x, pathRect.right, origin[0] / 100), lerp(pathRect.y, pathRect.bottom, origin[1] / 100)];
			var childAnchor = [lerp(childRect.x, childRect.right, origin[0] / 100), lerp(childRect.y, childRect.bottom, origin[1] / 100)];
			child.setAttribute('transform', 'translate(' + (pathAnchor[0] - childAnchor[0]) + ',' + (pathAnchor[1] - childAnchor[1]) + ')');
			pathRect = childRect;
		}
	}
	hatch (id, clr, useFIll, svg, path, density, randDensity, ang, width)
	{
		var luminance = (.2126 * clr[0] + .7152 * clr[1] + .0722 * clr[2]) / 255;
		var pattern = document.createElementNS(svgNS, 'pattern');
		pattern.id = id;
		pattern.style = 'transform:rotate(' + ang + 'deg)';
		pattern.setAttribute('width', '100%');
		pattern.setAttribute('height', '100%');
		pattern.setAttribute('patternunits', 'userSpaceOnUse');
		var path = path.cloneNode();
		var pathTxt = '';
		var x = 0;
		var interval = 15 / density * luminance;
		for (var i = 0; i < 99; i ++)
		{
			var off = random(-interval * randDensity, interval * randDensity);
			pathTxt += 'M ' + (x + off) + ' 0 L ' + (x + off) + ' ' + 999 + ' ';
			x += interval;
		}
		path.setAttribute('d', pathTxt);
		path.style = 'stroke-width:' + (width * (1 - luminance)) + ';stroke:black';
		pattern.appendChild(path);
		svg.appendChild(pattern);
		path = path.cloneNode(true);
		if (useFIll)
			path.style.fill = 'url(#' + id + ')';
		else
			path.style.stroke = 'url(#' + id + ')';
		svg.innerHTML += path.outerHTML;
	}
	// Physics Section Start
	set_transforms (dict)
	{
		for (var [key, val] of Object.entries(dict))
		{
			var node = document.getElementById(key);
			var trs = node.style.transform;
			var idxOfPosStart = trs.indexOf('translate(');
			var idxOfPosEnd = trs.indexOf(')', idxOfPosStart) + 1;
			var idxOfRotStart = trs.indexOf('rotate(');
			var idxOfRotEnd = trs.indexOf(')', idxOfRotStart) + 1;
			var pos = val.translation();
			var posStr = 'translate(' + (pos.x - node.getAttribute('width') / 2) + 'px,' + (pos.y - node.getAttribute('height') / 2) + 'px)';
			var rotStr = 'rotate(' + val.rotation() + 'rad)';
			if (idxOfRotStart > -1)
				trs = trs.slice(0, idxOfRotStart) + rotStr + trs.slice(idxOfRotEnd);
			else
				trs = rotStr + trs;
			if (idxOfPosStart > -1)
				trs = posStr + trs.slice(idxOfPosEnd);
			else
				trs = posStr + trs;
			node.style.transform = trs;
		}
	}
	remove (node)
	{
		if (rigidBodiesIds[node.id])
			delete rigidBodiesIds[node.id];
		else if (collidersIds[node.id])
			delete collidersIds[node.id];
		node.remove();
	}
	// Physics Section End
	main ()
	{
		
		var f = ts => {
			$.dt = (ts - $.prev) / 1000;
			$.prev = ts;
			window.requestAnimationFrame(f);
			
		};
		window.requestAnimationFrame(ts => {
			$.prev = ts;
			window.requestAnimationFrame(f);
		});
		// Physics Section Start
		setInterval(() => {
			world.step();
			$.set_transforms (rigidBodiesIds);
			$.set_transforms (collidersIds);
		}, 16);
		// Physics Section End
	}
}
var $ = new api;



import RAPIER from 'https://cdn.skypack.dev/@dimforge/rapier2d-compat';


var world;
var rigidBodiesIds = {};
var rigidBodyDescsIds = {};
var collidersIds = {};
RAPIER.init().then(() => {
	var gravity = {x : 0.0, y : -0.0};
	world = new RAPIER.World(gravity);
	
	
	
	
	
});

var D=`[["Light",4,1,6,0,"a","b","b",[0,50,100],false]]`;
var p=``;
var C=`{"a":[255,255,255,255],"b":[0,0,0,0]}`

var i = 0;
var d = JSON.parse(D);
var c = JSON.parse(C);
var g = [];
for (var e of d)
{
var l = e.length;
if (l > 10)
{
$.draw_svg (e[0], e[1], [e[2], e[3]], c[e[4]], e[5], c[e[6]], e[7], p.split('\n')[i].split(String.fromCharCode(1)), e[8], e[9], e[10], e[11], e[12], e[13], [e[14], e[15]], e[16], e[17], [e[18], e[19]], [e[20], e[21]], e[22], e[23], e[24], e[25], [e[26], e[27]], [e[28], e[29]], [e[30], e[31]], [e[32], e[33]], [e[34], e[35]], [e[36], e[37]], [e[38], e[39]], [e[40], e[41]], [e[42], e[43]], e[44], e[45], e[46], e[47], e[48], e[49], e[50]);
i ++;
}
else if (l > 6)
$.add_radial_gradient (e[0], [e[1], e[2]], e[3], e[4], c[e[5]], c[e[6]], c[e[7]], e[8], e[9]);
else if (l > 5)
$.copy_node (e[0], e[1], [e[2], e[3]], e[4], e[5]);
else
g.push(e);
}
for (var e of g)
add_group (e[0], [e[1], e[2]], e[3], e[4]);
$.main ()

</script>
</body>
</html>